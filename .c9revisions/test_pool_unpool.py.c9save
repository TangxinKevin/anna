{"ts":1416196744110,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\"\"\"Script to test unpooling op.\n\nPlease clone the repo, and add the path to the directory it is in to your PYTHONPATH environment variable.\nAlso you will need a copy of the stl10 dataset which is numpy compatible.\n\nPlease scp from:\nkronos:/data/stl10_matlab/\n\nYou will need to modify the line below which says:\ndata = numpy.load('/data/stl10_matlab/unsupervised.npy')\n\"\"\"\n\nimport numpy\nimport matplotlib.pyplot as pyplot\n\nimport theano.tensor as T\nimport theano\nfrom theano.sandbox.cuda.basic_ops import gpu_contiguous\nimport pylearn2.sandbox.cuda_convnet.pool as pool\nfrom pylearn2.sandbox.cuda_convnet.filter_acts import FilterActs\nfrom pylearn2.sandbox.cuda_convnet.img_acts import ImageActs\n\nfrom fastor.datasets import unsupervised_dataset\n\nfrom fastor.layers import cc_layers\n\ndef get_image(batch, i):\n    image = numpy.uint8(batch[:,:,:,i].transpose(1,2,0)/2.0*255.0)\n    return image\n\ndef find_switches(max_val, image_patch, recon_patch, count_patch):\n    #max_val = numpy.max(image_patch)\n    switches = image_patch == max_val\n    recon_patch += image_patch*switches\n    count_patch += switches\n    \ndef sexy_unpool(image, image_pool, ds=3, stride=1):\n    image_size = image.shape[0]\n    recon = numpy.zeros(image.shape)\n    count = numpy.zeros(image.shape)\n    j_x = -1\n    for i_x in range(0, image_size-ds+1, stride):\n        j_x += 1\n        j_y = -1\n        for i_y in range(0, image_size-ds+1, stride):\n            j_y += 1\n            x_slice = slice(i_x, i_x+ds)\n            y_slice = slice(i_y, i_y+ds)\n            image_patch = image[x_slice, y_slice]\n            recon_patch = recon[x_slice, y_slice]\n            count_patch = count[x_slice, y_slice]\n            max_val = image_pool[j_x, j_y]\n            find_switches(max_val, image_patch, recon_patch, count_patch)\n    count[count==0]=1\n    return recon/count\n\n# Get data and format it properly\ndata = numpy.load('/data/stl10_matlab/unsupervised.npy')\ntest_data = numpy.float32(data[0:128, :, :, :]) # grap enough data for a minibatch\ntest_data /= 255.0\ntest_data *= 2.0\n\ninput = test_data.transpose(1,2,3,0) # Output (channels, width, height, batch_size)\ninput = numpy.tile(input[0,:,:,:][None, :, :, :], (16, 1, 1, 1)) # (channels must be a multiple of 16)\n\n# Theano symbolic functions to do pooling and unpooling\ninput_symbol = T.ftensor4(name='input')\n\n# Make ops\npool_stride = 1\nds = 5\npool_op = pool.MaxPool(ds, pool_stride)\nunpool_op = pool.MaxPoolGrad(ds, pool_stride,0)\n\n# Make symbolic expressions\npool_symbol = pool_op(input_symbol)\nunpool_symbol = unpool_op(input_symbol, pool_symbol, pool_symbol)\n\npool_func = theano.function([input_symbol], pool_symbol)\nunpool_func = theano.function([input_symbol], unpool_symbol)\n\n# Run pooling and unpooling\npool_out = numpy.array(pool_func(input))\nunpool_out = numpy.array(unpool_func(input))\n\n# Display results on a random image\ni = numpy.random.randint(128)\nprint i\nimage_input = input[0,:,:,i]\nimage_pool = pool_out[0,:,:,i]\nimage_unpool = unpool_out[0,:,:,i]\nimage_sexy_unpool = sexy_unpool(image_input, image_pool, ds=ds, stride=pool_stride)\n\npyplot.subplot(2,2,1)\npyplot.imshow(image_input)\npyplot.title('original image')\npyplot.colorbar()\n\npyplot.subplot(2,2,2)\npyplot.imshow(image_pool)\npyplot.title('max pool image')\npyplot.colorbar()\n\npyplot.subplot(2,2,3)\npyplot.imshow(image_unpool)\npyplot.title('Alex unpool image')\npyplot.colorbar()\n\npyplot.subplot(2,2,4)\npyplot.imshow(image_sexy_unpool)\npyplot.title('Correct unpool image')\npyplot.colorbar()\n\npyplot.show()"]],"start1":0,"start2":0,"length1":0,"length2":3496}]],"length":3496}
